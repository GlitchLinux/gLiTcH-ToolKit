#!/usr/bin/env bash
#
# rEFInd Direct IMG ISO Creator âš¡
# Uses pre-made 16MB FAT32 image for minimal ISO creation
#
# Usage: ./create_direct_img_iso.sh [output_name]
# Example: ./create_direct_img_iso.sh refind-direct-2025
#
# This ultra-efficient version:
# 1. ğŸ“¥ Downloads pre-made 16MB FAT32 image
# 2. ğŸ“„ Creates minimal documentation
# 3. ğŸ’¿ Builds tiny ISO with direct IMG boot (~18MB total)
# 4. âš¡ No file duplication - boots directly from embedded image

set -e  # Exit on any error

# Configuration ğŸ¯
REFIND_IMG_URL="https://glitchlinux.wtf/FILES/REFIND_CUSTOM_&_THEMES/Refind_x64_16MB.img"
OUTPUT_NAME="${1:-Refind-x64-$(date +%Y%m%d)}"
DOWNLOAD_DIR="/tmp"
WORK_DIR="/tmp/refind_direct_build_$$"
CURRENT_DIR="$(pwd)"
IMG_FILE="$DOWNLOAD_DIR/Refind_x64_16MB.img"

# Color output functions ğŸ¨
print_info() {
    echo -e "\033[1;34m[INFO]\033[0m $1"
}

print_success() {
    echo -e "\033[1;32m[SUCCESS]\033[0m $1"
}

print_error() {
    echo -e "\033[1;31m[ERROR]\033[0m $1"
}

print_warning() {
    echo -e "\033[1;33m[WARNING]\033[0m $1"
}

print_step() {
    echo -e "\033[1;36m[STEP]\033[0m $1"
}

print_direct() {
    echo -e "\033[1;35m[DIRECT]\033[0m $1"
}

sudo apt update && sudo apt-get install wget genisoimage coreutils mtools mkisofs -y

# Check required tools ğŸ”
check_dependencies() {
    local missing_tools=()
    
    for tool in wget mkisofs sha256sum mdir; do
        if ! command -v "$tool" &> /dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "ğŸ“¦ Install with:"
        print_info "   sudo apt-get update"  
        print_info "   sudo apt-get install wget genisoimage coreutils mtools"
        exit 1
    fi
}

# Cleanup function ğŸ§¹
cleanup() {
    if [ -d "$WORK_DIR" ]; then
        print_info "ğŸ§¹ Cleaning up temporary build files..."
        rm -rf "$WORK_DIR"
    fi
}

trap cleanup EXIT

# Download pre-made rEFInd image ğŸ“¥
download_refind_img() {
    print_step "ğŸ“¥ Downloading pre-made rEFInd 16MB FAT32 image..."
    
    # Remove old download if exists
    [ -f "$IMG_FILE" ] && rm -f "$IMG_FILE"
    
    # Download the pre-made image
    if ! wget --progress=bar:force:noscroll \
              --timeout=30 \
              --tries=3 \
              --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36" \
              -O "$IMG_FILE" \
              "$REFIND_IMG_URL"; then
        print_error "âŒ Failed to download rEFInd image"
        print_info "ğŸŒ URL: $REFIND_IMG_URL"
        exit 1
    fi
    
    # Verify download
    if [ ! -f "$IMG_FILE" ] || [ ! -s "$IMG_FILE" ]; then
        print_error "âŒ Downloaded image is empty or doesn't exist"
        exit 1
    fi
    
    local img_size=$(du -h "$IMG_FILE" | cut -f1)
    print_success "âœ… Downloaded Refind_x64_16MB.img ($img_size)"
    
    # Verify it's a valid FAT image
    print_info "ğŸ” Verifying FAT32 image integrity..."
    if mdir -i "$IMG_FILE" ::/ >/dev/null 2>&1; then
        print_success "âœ… FAT32 image verification passed"
    else
        print_error "âŒ Downloaded file is not a valid FAT image"
        exit 1
    fi
    
    # Show image contents summary
    print_direct "ğŸ“Š Image contents:"
    local efi_dirs=$(mdir -i "$IMG_FILE" ::/EFI/ 2>/dev/null | grep "DIR" | wc -l || echo "0")
    local total_entries=$(mdir -i "$IMG_FILE" -/ ::/ 2>/dev/null | wc -l || echo "0")
    print_direct "   EFI subdirectories: $efi_dirs"
    print_direct "   Total entries: $total_entries"
}

# Create minimal ISO structure ğŸ“
create_minimal_structure() {
    print_step "ğŸ“ Creating minimal ISO structure..."
    
    # Create working directory
    mkdir -p "$WORK_DIR"
    cd "$WORK_DIR"
    
    # Copy the FAT32 image to work directory
    cp "$IMG_FILE" "./refind.img"
    
    print_direct "âš¡ ISO will boot directly from embedded refind.img"
    print_direct "ğŸ’¡ No EFI directory duplication needed!"
}

# Create comprehensive documentation ğŸ“„
create_documentation() {
    print_step "ğŸ“„ Creating comprehensive documentation..."
    
    cat > README.txt << EOF
rEFInd Direct IMG Boot Edition
=============================

Ultra-minimal rEFInd ISO booting directly from embedded 16MB FAT32 image.

ğŸ¯ Key Features:
- Pre-optimized 16MB FAT32 image from glitchlinux.wtf
- Direct IMG boot (no file duplication)
- Glitch cyberpunk theme included
- x64 UEFI optimized
- Maximum efficiency: ~18MB total ISO size

âš¡ Technical Details:
- Uses El Torito EFI boot specification
- UEFI firmware boots directly from embedded refind.img
- No EFI directory in ISO root (not needed!)
- FAT32 image contains complete rEFInd structure

ğŸš€ Usage:
1. Burn ISO to optical media or USB drive
2. Boot from media in UEFI mode  
3. rEFInd loads directly from embedded image
4. Navigate with arrow keys, Enter to boot

ğŸ”§ Contents:
- rEFInd Pro bootloader with Glitch theme
- Multiple bootloader support (Clover, GRUB)
- System utilities (shell, memtest, gdisk)
- Comprehensive OS detection
- Custom icon collection

ğŸ“± Source: glitchlinux.wtf
ğŸ—ï¸ Built: $(date)
ğŸ”– Version: rEFInd Direct IMG Boot

For updates: https://glitchlinux.wtf
EOF

    cat > INSTALL-DIRECT.txt << EOF
Direct IMG Boot Installation Guide
=================================

This ISO uses a direct boot approach for maximum efficiency.

ğŸ’¾ USB Creation:
   Linux/macOS:
   sudo dd if=${OUTPUT_NAME}.iso of=/dev/sdX bs=4M status=progress
   
   Windows:
   Use Rufus, balenaEtcher, or similar tool

ğŸ–¥ï¸ VM Testing:
   QEMU:
   qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ${OUTPUT_NAME}.iso -m 2048
   
   VirtualBox:
   Enable EFI in VM settings, attach ISO as optical drive

âš¡ Direct Boot Advantages:
- Smallest possible ISO size (~18MB)
- Fastest creation time
- No file duplication waste
- Single source of truth (embedded image)
- Maximum efficiency

ğŸ”§ Technical Implementation:
- ISO contains only refind.img + documentation
- El Torito spec points directly to refind.img
- UEFI firmware mounts and boots from FAT32 image
- Never accesses ISO root filesystem

ğŸ¯ Perfect For:
- Network deployment (minimal bandwidth)
- Quick testing and recovery
- Embedded systems with limited storage
- USB drives with space constraints

âš ï¸ UEFI Requirements:
- UEFI mode enabled (not Legacy BIOS)
- Secure Boot may need to be disabled
- Modern UEFI firmware (post-2010)
EOF

    cat > TECHNICAL-NOTES.txt << EOF
Technical Implementation Notes
=============================

ğŸ”¬ Direct IMG Boot Method:

ISO Structure:
${OUTPUT_NAME}.iso
â”œâ”€â”€ refind.img          (16MB FAT32 image - bootable)
â”œâ”€â”€ README.txt          (documentation)
â”œâ”€â”€ INSTALL-DIRECT.txt  (installation guide)
â””â”€â”€ TECHNICAL-NOTES.txt (this file)

El Torito Boot Specification:
- Boot catalog points to refind.img
- No emulation mode (direct EFI boot)
- UEFI firmware treats refind.img as EFI System Partition

Boot Process:
1. UEFI reads ISO boot catalog
2. Locates refind.img in ISO structure  
3. Mounts refind.img as FAT32 filesystem
4. Executes /EFI/BOOT/bootx64.efi from image
5. rEFInd loads with full functionality

Advantages vs Traditional Method:
- No EFI directory duplication in ISO root
- Smaller final ISO size (no waste)
- Single source of truth for all files
- Faster ISO creation (no file copying)
- Cleaner ISO structure

FAT32 Image Contents:
EFI/
â”œâ”€â”€ BOOT/               (rEFInd bootloader + theme)
â”œâ”€â”€ Clover/             (Clover bootloader)  
â”œâ”€â”€ GRUBFM/             (GRUB file manager)
â””â”€â”€ tools/              (system utilities)

Compatibility:
- Works with all modern UEFI systems
- Tested with major VM platforms
- Compatible with USB/optical media
- Supports both GPT and MBR partition schemes

Size Comparison:
- Traditional method: ~80MB (file duplication)
- Optimized method: ~40-50MB (smart optimization)
- Direct IMG method: ~18MB (maximum efficiency)

Build Source:
- Pre-made image: glitchlinux.wtf
- Optimized for x64 UEFI systems
- Professional quality assurance
EOF

    print_success "âœ… Comprehensive documentation created"
}

# Build ultra-minimal ISO ğŸ’¿
build_direct_iso() {
    print_step "ğŸ’¿ Building ultra-minimal direct IMG boot ISO..."
    
    # Get precise sizes for statistics
    local img_size_kb=$(du -k refind.img | cut -f1)
    local docs_size_kb=$(du -sk *.txt | awk '{sum+=$1} END {print sum}')
    local estimated_iso_kb=$((img_size_kb + docs_size_kb + 512))  # +512KB for ISO overhead
    
    print_direct "ğŸ“Š Size breakdown:"
    print_direct "   refind.img: ${img_size_kb}KB"
    print_direct "   Documentation: ${docs_size_kb}KB"
    print_direct "   Estimated ISO: ${estimated_iso_kb}KB (~$(($estimated_iso_kb/1024))MB)"
    
    # Create ISO with direct IMG boot
    print_direct "ğŸ”¥ Creating ISO with El Torito direct IMG boot..."
    
    if mkisofs -A "rEFInd Direct IMG Boot" \
               -V "REFIND_DIRECT" \
               -volset "REFIND_DIRECT_$(date +%Y%m%d)" \
               -J -R \
               -o "/tmp/${OUTPUT_NAME}.iso" \
               -eltorito-alt-boot \
               -efi-boot refind.img \
               -no-emul-boot \
               ./ >/dev/null 2>&1; then
        print_success "âœ… Direct IMG ISO created successfully"
    else
        print_error "âŒ ISO creation failed"
        return 1
    fi
    
    # Copy to target directory
    cp "/tmp/${OUTPUT_NAME}.iso" "$CURRENT_DIR/"
    print_success "ğŸ’¿ ISO moved to output directory"
}

# Show final statistics and verification ğŸ“Š
show_final_results() {
    print_step "ğŸ“Š Final results and verification..."
    
    cd "$CURRENT_DIR"
    
    # Generate checksums
    sha256sum "${OUTPUT_NAME}.iso" > "${OUTPUT_NAME}.iso.sha256"
    md5sum "${OUTPUT_NAME}.iso" > "${OUTPUT_NAME}.iso.md5" 2>/dev/null || true
    
    # Get final sizes
    local iso_size=$(du -h "${OUTPUT_NAME}.iso" | cut -f1)
    local iso_size_kb=$(du -k "${OUTPUT_NAME}.iso" | cut -f1)
    local iso_size_mb=$(($iso_size_kb / 1024))
    
    print_success "ğŸŠ Ultra-minimal rEFInd Direct IMG ISO completed!"
    echo
    print_direct "âš¡ DIRECT IMG BOOT RESULTS:"
    print_direct "   ğŸ“€ Final ISO size: $iso_size (${iso_size_kb}KB / ${iso_size_mb}MB)"
    
    # Size achievement verification
    if [ $iso_size_kb -lt 20480 ]; then  # Less than 20MB
        print_success "ğŸ† MAXIMUM EFFICIENCY ACHIEVED: Under 20MB!"
        local efficiency=$(( (80000 - iso_size_kb) * 100 / 80000 ))
        print_direct "   ğŸ¯ Space efficiency: ${efficiency}% improvement vs 80MB standard"
    elif [ $iso_size_kb -lt 25600 ]; then  # Less than 25MB
        print_success "ğŸ¥‡ Excellent efficiency: Under 25MB"
    else
        print_warning "âš ï¸ Larger than expected, but still very efficient"
    fi
    
    echo
    print_info "ğŸ“ Output Files:"
    print_info "   ğŸ“€ ${OUTPUT_NAME}.iso ($iso_size)"
    print_info "   ğŸ” ${OUTPUT_NAME}.iso.sha256"
    [ -f "${OUTPUT_NAME}.iso.md5" ] && print_info "   ğŸ” ${OUTPUT_NAME}.iso.md5"
    echo
    print_info "ğŸš€ Usage Commands:"
    print_info "   USB: sudo dd if=${OUTPUT_NAME}.iso of=/dev/sdX bs=4M status=progress"
    print_info "   Test: qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ${OUTPUT_NAME}.iso -m 2048"
    echo
    print_direct "âš¡ Direct IMG Boot Features:"
    print_direct "   âœ“ Boots directly from embedded 16MB FAT32 image"
    print_direct "   âœ“ No file duplication (maximum efficiency)"
    print_direct "   âœ“ Pre-optimized by glitchlinux.wtf"
    print_direct "   âœ“ Full rEFInd Pro functionality"
    print_direct "   âœ“ Glitch theme and all tools included"
    print_direct "   âœ“ Ultra-fast creation and deployment"
    echo
    print_direct "ğŸ”¬ Technical Achievement:"
    print_direct "   Original approach: 80MB (50% duplication waste)"
    print_direct "   Direct IMG approach: ${iso_size} (maximum efficiency)"
    
    print_success "âš¡ Ultra-efficient rEFInd ready for lightning deployment! âš¡"
}

# Main execution flow ğŸ¯
main() {
    echo "âš¡ğŸ’¿ rEFInd DIRECT IMG BOOT ISO Builder ğŸ’¿âš¡"
    echo "=============================================="
    print_direct "ğŸ¯ Maximum Efficiency: Direct boot from embedded 16MB image"
    print_direct "ğŸš€ No file duplication - boots directly from FAT32 IMG"
    print_info "ğŸ“… Build started: $(date)"
    print_info "ğŸ·ï¸ Output name: $OUTPUT_NAME"
    print_info "ğŸŒ Source IMG: $REFIND_IMG_URL"
    echo

    # Execute build steps
    check_dependencies
    download_refind_img
    create_minimal_structure
    create_documentation
    build_direct_iso
    show_final_results
    
    print_success "âš¡ Direct IMG boot ISO complete! Ultimate efficiency achieved! âš¡"
}

# Execute main function
main "$@"
