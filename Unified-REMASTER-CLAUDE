#!/bin/bash

# Seamless Squashfs and Live ISO Creator - Surgical Fusion Approach
# Downloads original scripts and surgically connects them while preserving all functionality
# Especially preserves ALL boot configurations and ISO creation logic

set -e

# Color codes for consistent output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;35m'
BLUE='\033[0;34m'
NC='\033[0m'

# Script URLs
SQUASH_URL="https://raw.githubusercontent.com/GlitchLinux/gLiTcH-ToolKit/refs/heads/main/SQUASH-FILESYSTEM"
ISO_URL="https://raw.githubusercontent.com/GlitchLinux/gLiTcH-ToolKit/refs/heads/main/LIVE-ISO-CREATOR"

# Working directory for downloaded scripts
SCRIPT_DIR="/tmp/seamless_iso_$$"
mkdir -p "$SCRIPT_DIR"

# Cleanup on exit
trap "rm -rf $SCRIPT_DIR" EXIT

# Function to print messages
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Download original scripts
download_scripts() {
    print_info "Downloading original scripts from GitHub..."
    
    if ! wget -q "$SQUASH_URL" -O "$SCRIPT_DIR/squash_original.sh"; then
        print_error "Failed to download SQUASH-FILESYSTEM.sh"
        exit 1
    fi
    
    if ! wget -q "$ISO_URL" -O "$SCRIPT_DIR/iso_original.sh"; then
        print_error "Failed to download LIVE-ISO-CREATOR.sh"
        exit 1
    fi
    
    chmod +x "$SCRIPT_DIR"/*.sh
    print_success "Scripts downloaded successfully"
}

# Gather all configuration upfront
gather_configuration() {
    clear
    echo ""
    echo -e "${GREEN}╭─────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC} Seamless Squashfs & Live ISO Creator       ${GREEN}│${NC}"
    echo -e "${GREEN}│${NC} Automated remastering and ISO generation   ${GREEN}│${NC}"
    echo -e "${GREEN}╰─────────────────────────────────────────────╯${NC}"
    echo ""
    
    # 1. Get ISO name
    while true; do
        echo -n "Enter name for the ISO (without .iso extension): "
        read ISO_NAME
        if [ -z "$ISO_NAME" ]; then
            print_error "ISO name cannot be empty"
            continue
        fi
        if [[ "$ISO_NAME" =~ [^a-zA-Z0-9_-] ]]; then
            print_error "ISO name can only contain letters, numbers, hyphens, and underscores"
            continue
        fi
        break
    done
    
    # 2. Get distro type
    echo ""
    echo "Select base distribution type:"
    echo "  1) Debian-based (uses /live)"
    echo "  2) Ubuntu-based (uses /casper)"
    while true; do
        echo -n "Enter choice (1 or 2): "
        read choice
        case $choice in
            1)
                DISTRO_TYPE="debian"
                LIVE_DIR="live"
                print_success "Selected Debian-based distribution"
                break
                ;;
            2)
                DISTRO_TYPE="ubuntu"
                LIVE_DIR="casper"
                print_success "Selected Ubuntu-based distribution"
                break
                ;;
            *)
                print_error "Invalid choice. Please enter 1 or 2"
                ;;
        esac
    done
    
    # 3. Get working directory path
    echo ""
    echo "Available locations for working directory:"
    echo "  /tmp     - Temporary storage (fastest)"
    echo "  /home    - Home directory"
    echo "  /mnt     - Mount points"
    echo ""
    while true; do
        echo -n "Enter path where to create the working directory: "
        read WORK_PATH
        if [ -z "$WORK_PATH" ]; then
            print_error "Path cannot be empty"
            continue
        fi
        if [ ! -d "$WORK_PATH" ]; then
            print_error "Directory $WORK_PATH does not exist"
            continue
        fi
        if [ ! -w "$WORK_PATH" ]; then
            print_error "Directory $WORK_PATH is not writable"
            continue
        fi
        break
    done
    
    # Additional configuration
    echo ""
    echo -n "Enter hostname for the live system [live-system]: "
    read HOSTNAME
    HOSTNAME=${HOSTNAME:-live-system}
    
    # Export variables for use in modified scripts
    export ISO_NAME
    export DISTRO_TYPE
    export LIVE_DIR
    export WORK_PATH
    export HOSTNAME
    export PARENT_DIR="$WORK_PATH/$ISO_NAME"
}

# Create modified squash script
create_modified_squash() {
    cat > "$SCRIPT_DIR/squash_modified.sh" << 'SQUASH_HEADER'
#!/bin/bash

# Modified SQUASH-FILESYSTEM.sh - Automated version
# Preserves ALL original functionality, only modifies input/output

# Import configuration from environment
ISO_NAME="$ISO_NAME"
WORK_PATH="$WORK_PATH"
HOSTNAME="$HOSTNAME"

# Set paths automatically
DRIVE_PATH="$WORK_PATH"
WRKDIR="remastered"
WORK="$DRIVE_PATH/$WRKDIR"
SQFS="$DRIVE_PATH/filesystem.squashfs"

# Original script content follows with input sections removed
SQUASH_HEADER

    # Extract everything after the input gathering section from the original script
    # Preserve ALL functions and execution logic
    sed -n '/^# Function to fix systemd issues/,$ p' "$SCRIPT_DIR/squash_original.sh" | \
    sed '/^# Main script starts here/,/^# Set up paths/ {
        /^# Main script starts here/r /dev/stdin
        d
    }' << 'INPUT_REPLACEMENT' >> "$SCRIPT_DIR/squash_modified.sh"

# Main script starts here
# Skip all the interactive input - we already have our values

# Color codes preserved from original
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;35m'
BLUE='\033[0;32m'
NC='\033[0m'

# Check if running as root
if [ "$(whoami)" != "root" ]; then
    echo -e "${RED}This script must be run as root.${NC}"
    echo "Re-running with sudo..."
    exec sudo "$0" "$@"
fi

# Functions preserved from original
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

INPUT_REPLACEMENT

    # Ensure the script continues with the original logic
    echo '
# Use our pre-configured paths
echo
print_info "Configuration (automated):"
echo "  Working directory: $WORK"
echo "  Output file: $SQFS"
echo "  Hostname: $HOSTNAME"
echo

# Continue with original script logic from path checking onwards
' >> "$SCRIPT_DIR/squash_modified.sh"

    chmod +x "$SCRIPT_DIR/squash_modified.sh"
}

# Create modified ISO script
create_modified_iso() {
    # Create a wrapper that feeds the parent_dir automatically
    cat > "$SCRIPT_DIR/iso_modified.sh" << 'ISO_SCRIPT'
#!/bin/bash

# Modified LIVE-ISO-CREATOR.sh - Automated version
# Preserves ALL original functionality, especially boot configurations

# Import configuration
PARENT_DIR="$PARENT_DIR"
ISO_NAME="$ISO_NAME"

# Create a response file for the ISO creator
RESPONSE_FILE="/tmp/iso_responses_$$"
cat > "$RESPONSE_FILE" << EOF
$PARENT_DIR
$ISO_NAME


EOF

# Run the original ISO creator with automated input
# Preserving ALL original boot configurations and xorriso commands
ISO_SCRIPT

    cat "$SCRIPT_DIR/iso_original.sh" >> "$SCRIPT_DIR/iso_modified.sh"
    
    # Modify only the input reading part to use our parent_dir
    sed -i 's/read -p "   -> " parent_dir/parent_dir="$PARENT_DIR"/' "$SCRIPT_DIR/iso_modified.sh"
    
    chmod +x "$SCRIPT_DIR/iso_modified.sh"
}

# Execute the complete workflow
execute_workflow() {
    print_info "Starting automated remastering and ISO creation process..."
    
    # Phase 1: Create squashfs using modified script
    print_info "Phase 1: Creating filesystem squashfs..."
    if ! (cd "$SCRIPT_DIR" && sudo -E ./squash_modified.sh); then
        print_error "Squashfs creation failed"
        exit 1
    fi
    
    # Phase 2: Prepare ISO structure
    print_info "Phase 2: Preparing ISO structure..."
    
    # Create the ISO directory structure
    mkdir -p "$PARENT_DIR/$LIVE_DIR"
    
    # Move squashfs to live/casper directory
    if [ -f "$WORK_PATH/filesystem.squashfs" ]; then
        mv "$WORK_PATH/filesystem.squashfs" "$PARENT_DIR/$LIVE_DIR/filesystem.squashfs"
        print_success "Moved squashfs to $LIVE_DIR directory"
        
        # Remove remastered directory to save space
        if [ -d "$WORK_PATH/remastered" ]; then
            rm -rf "$WORK_PATH/remastered"
            print_info "Removed temporary remastered directory"
        fi
    else
        print_error "filesystem.squashfs not found!"
        exit 1
    fi
    
    # Copy kernel and initrd with full filenames
    print_info "Copying kernel and initrd files..."
    
    # Find and copy vmlinuz
    for vmlinuz in /boot/vmlinuz-*; do
        if [ -f "$vmlinuz" ]; then
            cp "$vmlinuz" "$PARENT_DIR/$LIVE_DIR/$(basename $vmlinuz)"
            print_success "Copied $(basename $vmlinuz)"
            break
        fi
    done
    
    # Find and copy initrd
    for initrd in /boot/initrd.img-* /boot/initramfs-*; do
        if [ -f "$initrd" ]; then
            cp "$initrd" "$PARENT_DIR/$LIVE_DIR/$(basename $initrd)"
            print_success "Copied $(basename $initrd)"
            break
        fi
    done
    
    # Create appropriate symlinks for live system
    cd "$PARENT_DIR/$LIVE_DIR"
    if [ "$DISTRO_TYPE" = "ubuntu" ]; then
        # Ubuntu/casper expects specific names
        ln -sf vmlinuz-* vmlinuz 2>/dev/null || true
        ln -sf initrd.img-* initrd 2>/dev/null || true
    else
        # Debian live can use symlinks
        ln -sf vmlinuz-* vmlinuz 2>/dev/null || true
        ln -sf initrd.img-* initrd.img 2>/dev/null || true
    fi
    cd - >/dev/null
    
    # Verify structure
    print_info "Verifying ISO structure..."
    if [ -f "$PARENT_DIR/$LIVE_DIR/filesystem.squashfs" ] && \
       ls "$PARENT_DIR/$LIVE_DIR"/vmlinuz* >/dev/null 2>&1 && \
       ls "$PARENT_DIR/$LIVE_DIR"/initrd* >/dev/null 2>&1; then
        print_success "ISO structure ready"
        echo ""
        echo "Structure created:"
        ls -lh "$PARENT_DIR/$LIVE_DIR/" | grep -E 'filesystem|vmlinuz|initrd'
        echo ""
    else
        print_error "ISO structure incomplete"
        exit 1
    fi
    
    # Phase 3: Create ISO using the original script's logic
    print_info "Phase 3: Creating bootable ISO..."
    print_info "The ISO creator will now run with all original boot configurations preserved"
    echo ""
    
    # Run the modified ISO creator that uses our parent_dir
    if ! (cd "$SCRIPT_DIR" && sudo -E ./iso_modified.sh); then
        print_error "ISO creation failed"
        exit 1
    fi
    
    print_success "Complete! Your bootable ISO has been created"
    echo ""
    
    # Final cleanup option
    echo -n "Remove working directory $WORK_PATH (except the ISO)? (Y/n): "
    read cleanup
    if [[ ! "$cleanup" =~ ^[Nn]$ ]]; then
        # Be very careful to only remove the working files, not the ISO
        if [ -d "$PARENT_DIR" ]; then
            rm -rf "$PARENT_DIR"
        fi
        print_success "Working directory cleaned"
    fi
}

# Main execution
main() {
    # Check for root early
    if [ "$(whoami)" != "root" ]; then
        echo -e "${RED}This script must be run as root.${NC}"
        echo "Re-running with sudo..."
        exec sudo "$0" "$@"
    fi
    
    # Download scripts
    download_scripts
    
    # Gather all configuration
    gather_configuration
    
    # Create modified versions
    create_modified_squash
    create_modified_iso
    
    # Execute the workflow
    execute_workflow
}

# Run main
main "$@"
